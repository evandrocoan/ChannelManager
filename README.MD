# Channel Manager

The plugin `channel_manager.py` creates the files `channel.json` and `repository.json` based on the
`.gitmodules` file on the Sublime Text Data folder (the folder at `Packages/../`). To call it, you
can open the command palette and type `YourChannelName: Generate Channel File`. See the following
threads for more information about the `Package Control` channel and repository files:

1. https://packagecontrol.io/docs/dependencies  DOCS - Dependencies
1. https://packagecontrol.io/docs/channels_and_repositories Channels and Repositories
1. https://github.com/wbond/package_control/issues/1089 Package dependencies (install dependent sublime packages)
1. https://forum.sublimetext.com/t/dependencies-in-package-control-3/14646 Dependencies in Package Control 3
1. https://forum.sublimetext.com/t/modules-dependencies-best-practices/21037 Modules + Dependencies : Best Practices?
1. https://github.com/wbond/package_control/issues/1070 [Meta] What to do when a dependency update includes breaking changes?


## Table of Contents

- [Channel Manager](#channel-manager)
  * [Table of Contents](#table-of-contents)
  * [Introduction](#introduction-go-to-top)
    + [Tags Management](#tags-management-go-to-top)
    + [Submodules Manager](#submodules-manager-go-to-top)
    + [Channel Installer/uninstaller](#channel-installer-uninstaller-go-to-top)
  * [How to Build a Channel](#how-to-build-a-channel-go-to-top)
  * [How to Use a Channel](#how-to-use-a-channel-go-to-top)
    + [Multiple Channels Installation](#multiple-channels-installation-go-to-top)
  * [Commands](#commands-go-to-top)
  * [Installation Notes](#installation-notes-go-to-top)
  * [License](#license-go-to-top)

* The table of contents used on this Markdown was generated by: [GitHub Wiki TOC generator](http://ecotrust-canada.github.io/markdown-toc/)



___
## Introduction <sub><sub>[Go to Top](#channel-manager)</sub></sub>

ChannelManager is dependency which manages the packages installed by git as submodules. It allows to
create the channel files required by Package Control to list and install packages. It is Currently
implemented two different bundle of package bounded by `.gitmodules` files. The
[StudioChannel](https://github.com/evandrocoan/SublimeStudioChannel) and the
[AmxxChannel](https://github.com/evandrocoan/SublimeAmxxChannel).

1. **StudioChannel** This is one of the first channels implemented using the `ChannelManager`. It
   contains about 100 packages for the stable version and 150 for the development version. It has a
   custom installation wizard to guide you through the installation steps and therefore call the
   `ChannelManager`'s installer passing the required configurations for the
   [SublimeStudio](https://github.com/evandrocoan/SublimeStudio).

1. **AmxxChannel** This is a smaller channel of packages with about 20 packages focused on just for
   programming for AMX Mod X Pawn language at
   [SublimeAmxxSimpleIDE](https://github.com/evandrocoan/SublimeAmxxSimpleIDE)

The channel creation is based on the existence of a
[.gitmodules](https://git-scm.com/docs/gitmodules) file on the root of your Sublime Text Data
folder. For example, at the portable version of Sublime Text the folder structure would look like
this:
```java
$ tree
.
├── .git
│   ├── COMMIT_EDITMSG
|   ...
├── .gitmodules
├── Cache
│   ├── ActionScript
│   │   └── ActionScript.sublime-syntax.cache
|   ...
├── Installed Packages
│   ├── 0_package_control_loader.sublime-package
│   ├── Amxx Pawn.sublime-package
│   ...
├── KEEPME
|   ...
└── Packages
    ├── amxmodx
    │   ├── amxx.sublime-settings
    ...
```

The contents of the file `.gitmodules` follow the requirements by
[.gitmodules](https://git-scm.com/docs/gitmodules), but also including new keys used to generate the
channel files. Currently there are implemented the following keys:
```java
[submodule "Packages/Notepad++ Color Scheme"]
    path = Packages/Notepad++ Color Scheme
    url = https://github.com/evandrocoan/SublimeNotepadPlusPlusTheme
    upstream =
    dependency = PythonDebugTools, regex
    tags = 3143, 3147
```

The `tags` is a comma separated list of remote tags and the version of Sublime they are aimed to be
used. For example, `tags = 3143, 3147` indicates the repository `Notepad++ Color Scheme` has the
following git tags called `3143` and `3147`.

The key `dependency` is comma separate lists of `dependencies` a package has. If the dependency key
start with number like in `dependency = 50, PythonDebugTools, regex`, it would mean that the package
`Packages/Notepad++ Color Scheme` would be a dependency with load order of 50, which requires as
dependency the dependencies `PythonDebugTools` and `regex`.

As well it could just be `dependency = 50`, then it would mean `Packages/Notepad++ Color Scheme` is
a dependency which has the loading order set as `50`. You can learn more about dependencies reading
[Package Control, Docs: Dependencies](https://packagecontrol.io/docs/dependencies). If it had no key
`dependency` then it mean it is just a `Package` with no dependencies.

The `upstream` can be empty or not present if you would like to. It is used to set your repository
`upstream` when the project is a fork of some another project. For example, let us suppose you liked
the project `https://github.com/evandrocoan/SublimeNotepadPlusPlusTheme` and created a fork of it on
Github. Now, instead of installing the original package from `evandrocoan`, you installed your fork,
from your address `https://github.com/your_user_name/SublimeNotepadPlusPlusTheme`, then you would
set the `upstream` key pointing to the original repository and the `url` key for your fork of it.


### Tags Management <sub><sub>[Go to Top](#channel-manager)</sub></sub>

Settings tags like `3143` is useful when a package has ceased working for old build of Sublime Text.
For example, on Sublime Text development build `3147`, the package `Notepad++ Color Scheme` stopped
working completely ([CoreIssue$1983](https://github.com/SublimeTextIssues/Core/issues/1983)) however
the fix for build `3147` also broke completely the package for Sublime Text stable build `3143`.
Hence, we must to create a tag which targets the last commit which is working for build `3143`.
Moreover, when some user using the stable build `3143` installs the `Notepad++ Color Scheme`, they
must install the one from the tag `3143`, and not the one from the master branch, which has the
latest fixes for build development build `3144` or newer. Stills also to do automatic tagging of the
latest release package is working for Sublime Text as the tag `3143` just mentioned, however this
seems not much required to be done as should there be only a few exceptions for when a packages
stops working for some build of Sublime Text.

Currently the channel generation is limited to setting the download link to a tag pointing to the
the repository master branch. For now, it is disabled all tag prefixes, i.e., tags which are not
strictly "0.0.0", because we cannot handle repositories which have a tag prefix for each platforms
as Linux and Windows. Then we create a unified tag which is based on the current master branch.
Despite it was implemented the checking for each submodule for the latest tag available, then
properly setting the download URL pointing to the last tag, based on the latest commit date.
Currently it is only partially implemented the tag management. It is required to also implement on
the `.gitmodules` file, the `tag_prefix` field to select which is the tag prefix, and for which
platform.

It would be useful for tagging a large set of packages which can be considered stable. This approach
should be much batter than the current one where the user always download the current version
available at the master branch when the user installed the package. Such approach is not very
welcomed because would allow several clients to be using different versions of the package while all
of them think they are using the latest version available at the moment, however just the most
recent installations would be using the lasted version, whereas the other installations would be
using some older version.


### Submodules Manager <sub><sub>[Go to Top](#channel-manager)</sub></sub>

The plugin `submodules_manager.py` run several operations based on the `.gitmodules` file on the
Sublime Text Data folder (the folder at `Packages/../`) and `Backstroke.gitmodules` file on the
Sublime Text Data folder (the folder at `Packages/../Local`). However, still to do a implementation
of a configuration which will allow you to change the locations of these files by settings files. So
you can put them where you please most.

Here is a sample of the structure of both files, the `Backstroke.gitmodules` is not indented on
purpose for backward compatibility with `Python 2.7` configparser which does not allow indented
blocks. If you are planing in only using `Python 3`, you can indent both files. The file
`.gitmodules` is compatible with `Python 3` due a created wrapper which removes the indentation
before sending the files contents to the `configparser`:

**.gitmodules**
```shell
[submodule "Packages/Better CoffeeScript"]
    path = Packages/Better CoffeeScript
    url = https://github.com/evandrocoan/sublime-better-coffeescript
    upstream = https://github.com/aponxi/sublime-better-coffeescript
[submodule "Packages/BufferScroll"]
    path = Packages/BufferScroll
    url = https://github.com/evandrocoan/BufferScroll
    upstream = https://github.com/titoBouzout/BufferScroll
    dependency = PythonDebugTools
```

**Backstroke.gitmodules**
```shell
[submodule "Packages"]
url = https://github.com/evandrocoan/Packages
upstream = https://github.com/sublimehq/Packages
backstroke = https://backstroke.us/_48c38b8a08174b2d82221f7

[submodule "Packages/ANSIescape"]
url = https://github.com/evandrocoan/SublimeANSI
upstream = https://github.com/aziz/SublimeANSI
backstroke = https://backstroke.us/_2d82221f793d50c2f75952c
```

Hence, if you would like to receive updates from the
`https://github.com/evandrocoan/SublimeNotepadPlusPlusTheme` upstream, you can set the key `upstream`
pointing to the upstream of the original package at
`https://github.com/evandrocoan/SublimeNotepadPlusPlusTheme`. Therefore, your settings file would
look like:
```java
[submodule "Packages/Notepad++ Color Scheme"]
    path = Packages/Notepad++ Color Scheme
    url = https://github.com/your_user_name/SublimeNotepadPlusPlusTheme
    upstream = https://github.com/evandrocoan/SublimeNotepadPlusPlusTheme
    dependency = PythonDebugTools, regex
    tags = 3143, 3147
```

Sadly, this feature is not implemented yet. However, the `upstream` key is used by the plugin
`submodules_manager.py`, with the command line argument `-f`. The `submodules_manager.py` provides
some commands which are not available from Sublime Text due they being too long to run. Moreover is
proper to use a dedicated shell for them. You can see the available options for the
`submodules_manager.py` by running it:
```java
$ python3 submodules_manager.py
[submodules_manager.py] 14:44:07  454080    2707 Entering on main(0) None
[submodules_manager.py] 14:44:07  454322     242 ( print_command_line_arguments ) len(sys.argv): 1
[submodules_manager.py] 14:44:07  454403      81 ( print_command_line_arguments ) arg: submodules_manager.py
usage: submodules_manager.py [-h] [-a] [-b] [-f] [-p] [-t]

Update Sublime Text Channel

optional arguments:
  -h, --help        show this help message and exit
  -a, --all         Generate all assets
  -b, --backstroke  Check all backstroke registered repositories updates with
                    their upstream. The backstroke URLs are now in a separate
                    file on: Local/Backstroke.gitmodules
  -f, --find-forks  Find all repositories forks, fetch their branches and
                    clean the duplicated branches. The upstream data in on the
                    `.gitmodules` file on: Sublime Text `Data` folder
  -p, --pull        Perform a git pull from the remote repositories
  -t, --push-tags   Perform a git push for all submodules tags to their
                    respective remote repository
```

By just calling the `submodules_manager.py` with the `--find-forks` argument, it will run
automatically through all your git submodules listed on the file `.gitmodules`. But still to do a
argument to be passed to the command to allow select one specific repository to run the command,
instead of running it right away through all your installed repositories, thing which can take
several hours.

The `find_forks` command call the python package
[find_forks](https://github.com/frost-nzcr4/find_forks) which finds all forks of user/repository on
github and add it as git remote to your local cloned repository. It is useful to find interesting
commits of old repository with many updated forks, fresh repository with many forks that original
author doesn't want or doesn't have time to merge.


### Channel Installer/uninstaller <sub><sub>[Go to Top](#channel-manager)</sub></sub>

The plugins `channel_installer.py`/`channel_uninstaller.py` performs the installation and
uninstallation of the of all the channel packages by the `Package Control` when installing the
Stable Version, or by `git` when installing the Development Version of the channel.

Currently the installer has some hard coded configurations which are implemented directly on the
code. But futurely they should be moved on from the dependency `ChannelManager` to the package which
actually is using the dependency `ChannelManager` to do the channel administration.



___
## How to Build a Channel <sub><sub>[Go to Top](#channel-manager)</sub></sub>

The original purpose of the channel is to be small, something like just a few hundred of packages.
However, you can scale up, if you do not actually install everything as a git submodule. The channel
can in also be installed at once, including all its packages. That means, if you have big channel
like with 1000 packages, you can call the channel installer, and those 1000 packages are going to be
installed in your Sublime Text.

The installer provides two installation alternatives. The Development Version and the Stable
Version. By installing the Stable Version, all the packages in your channel are going to be
installed, except the one listed in the `settings.json` file. Then, for example, you can have as
much as 1000 packages in your channel, but list 960 of them by their names at the `settings.json`.
Hence only 40 packages are going to be installed when the channel installer run.

However, this is only true if the user is installing the Stable Version of the channel. The
Development Version will clone by `git` all the 1000 packages and then add the 960 packages listed
on the `settings.json` file to the user `ignored_packages` settings. Currently the `settings.json`
file is generated based on your `ignored_packages` settings, i.e., it copies all the packages you
have set on your `ignored_packages` settings and add them to the `settings.json`.

This was designed like that because the original goal of this is to be just a small channel for a
few packages you always install, or are developing. However, if you wish to scale up build very
large, channels you can change easily change this behavior by including the `ignored_packages`
manually or from another source other than the user settings `ignored_packages`, or just deciding
not to use the channel installer to install the channel packages and just pick they one by one, as
you usually do with the default `Package Control` channel.

1. Install Sublime Text portable version, you can download it at:
   [https://www.sublimetext.com/3](https://www.sublimetext.com/3)

1. Open your Sublime Text loose `Packages` folder by going the menu `Preferences -> Browse
   Packages...` Now open a command line you the folder which just opened:

   <details>
   <p>

   **Linux**
   ![Opening Linux Command Line](http://i.imgur.com/VA4zC7F.gif)
   </p>
   </details><br>

   <details>
   <p>

   **Windows**
   ![Opening Windows Command Line](http://i.imgur.com/iYwE4IO.gif)
   </p>
   </details><br>

1. Use your command line and go to the parent folder of your `Packages` folder, and create a git
   repository, which will hold/tie together all the packages available in you channel. For example:
   ```bash
   cd ..
   git init
   printf "# Main Repository\n\nFor my packages' channel." > README.md
   git add README.md
   git commit -m "Added README.md"
   git remote add origin https://github.com/your_user_name/main_repository
   ```

1. Now your `Main Repository` is set up, use the same command line to install the Packages you want
   to add to your channel and adding them as git submodules to the main repository. For example:
   ```bash
   git clone --recursive https://github.com/jisaacks/GitGutter "Packages/GitGutter"
   git submodule add -- https://github.com/jisaacks/GitGutter "Packages/GitGutter"
   git commit -m "Added the first package to my channel."
   ```

1. Now your `.gitmodules` file was created by git. It should look like this:
   ```java
   [submodule "Packages/GitGutter"]
       path = Packages/GitGutter
       url = https://github.com/jisaacks/GitGutter
   ```

   With this setup, you can customize your file adding the required information to build up the channel.
   Let us start by adding the keys for the `ChannelManager` installer & uninstaller:
   ```java
   [submodule "Packages/GitGutter"]
       path = Packages/GitGutter
       url = https://github.com/jisaacks/GitGutter

   [submodule "Packages/ChannelManager"]
       path = Packages/ChannelManager
       url = https://github.com/evandrocoan/SublimeChannelManager
       upstream =
       dependency = 50, PythonDebugTools
   ```

   The packages `ChannelManager` is responsible for generating the channel files, installing and
   uninstalling them. As it is set on the `.gitmodules` file, it defines itself as being a
   dependency with load order of `50` and requiring another dependency called `PythonDebugTools`.
   You can read more about the dependency load order on [Package Control, Docs:
   Dependencies](https://packagecontrol.io/docs/dependencies)

   As it is a dependency you could just skip it, i.e., not add this entry to your `.gitmodules` file
   as `Package Control` would install it when you requires it on the actual package which provides
   the commands. However, if you do not add it:

      1. The installation could just not work, if the dependency `ChannelManager` and
         `PythonDebugTools` are not available on the `Package Control` default channel.
      1. You cannot use all the features available because currently it is dependent on git
         submodules and Package Control cannot clone the submodules together yet. Therefore, cannot
         use the features dependent on the submodules as the `find_forks` command.

   But also, you can add `ChannelManager` to enforce the policy of development, adding
   `ChannelManager` here allow you to easily edit its code, fix bugs or improve whatever it is doing
   as you already have a full git repository at hand, you just need to change the remote to a new
   repository or for a fork of yours at GitHub.

   Therefore as you may notice, was skipped the addition of the dependency `PythonDebugTools` as it is
   not dependent on git submodules and there is not much room for improvement or changes on it.
   However if you like you can also add it as a package. You just need to add the following entry to
   your `.gitmodules`:
   ```java
   [submodule "Packages/GitGutter"]
       path = Packages/GitGutter
       url = https://github.com/jisaacks/GitGutter

   [submodule "Packages/ChannelManager"]
       path = Packages/ChannelManager
       url = https://github.com/evandrocoan/SublimeChannelManager
       upstream =
       dependency = 50, PythonDebugTools

   [submodule "Packages/PythonDebugTools"]
       path = Packages/PythonDebugTools
       url = https://github.com/evandrocoan/PythonDebugTools
       upstream =
       dependency = 49
   ```

1. Now you added the basics, you may notice they were not added as `git submodules` by the commands
   `git clone --recursive repo_url` and `git submodule add -- repo_url "Packages/package_name"`.
   Moreover you can or cannot do so if you like. The `ChannelManager` only requires to the file
   `.gitmodules` to exists in the pre-configured location, which we are about do to. Other than
   that, you do not need to have a parent repository which holds a valid `.gitmodules` file by your
   `git` client.

   However, it is required for some commands available to work properly as the command `Pull &
   Rebase all Packages`. Beyond that advised and nice to have a parent repository which validly by
   `git` ties together all the packages, because you can in only open place manage all your packages
   and easily create commits, pulls, pushes, etc. On this picture we can see some of this
   integration by a `git client Graphic Interface`:

   ![git client Graphic Interface](https://i.imgur.com/Q3DngpF.png)

   To create the channel you need the configuration loader for the dependency `ChannelManager`. This
   configuration loader would be a Sublime Text Package which requires the `ChannelManager` as a
   dependency and call its installer, uninstaller and commands available passing the configuration
   required by the `ChannelManager` dependency to run its operations.

   First of all let us create the folder for our new channel, you can name it as you like as long as
   there is no other package installed with the same. Assuming you still have the command line
   opened on the folder we were before, you can create the folder for the your channel:
   ```bash
   mkdir -p "Packages/MyBrandNewChannel"
   cd "Packages/MyBrandNewChannel"
   git init
   ```

   But without forgetting, we need to create an entry for the channel on our `.gitmodules` file. At
   the end of it all, the `.gitmodules` would look like this for the channel named
   `MyBrandNewChannel`:
   ```java
   [submodule "Packages/GitGutter"]
       path = Packages/GitGutter
       url = https://github.com/jisaacks/GitGutter

   [submodule "Packages/ChannelManager"]
       path = Packages/ChannelManager
       url = https://github.com/evandrocoan/SublimeChannelManager
       upstream =
       dependency = 50, PythonDebugTools

   [submodule "Packages/PythonDebugTools"]
       path = Packages/PythonDebugTools
       url = https://github.com/evandrocoan/PythonDebugTools
       upstream =
       dependency = 49

   [submodule "Packages/MyBrandNewChannel"]
       path = Packages/MyBrandNewChannel
       url = https://github.com/your_user_name/MyBrandNewChannel
       upstream =
       dependency = ChannelManager, PythonDebugTools
   ```

   * Note: Due Package Control currently not accept dependencies requiring dependencies, we also
     need to add the `ChannelManager` dependencies to the `MyBrandNewChannel` dependencies list. On
     this case, we added the dependency `PythonDebugTools` to the `MyBrandNewChannel` dependencies
     list, as `ChannelManager` requires the `PythonDebugTools` as dependency. See the following
     issue for details about when this should be correctly supported by `Package Control`:

     1. [package_control#1300](https://github.com/wbond/package_control/issues/1300) If a dependency has a dependency, its dependencies are not installed

1. Now on this new package called `Packages/MyBrandNewChannel`, you need to create the plugin to
   call the channel manager passing the required configurations. In the following we may see a full
   example configuration file, you can save it inside the folder `Packages/MyBrandNewChannel` with
   the name you like most as `settings.py` or `settings_and_commands.py`:
   ```python
   import os

   import sublime
   import sublime_plugin

   from channel_manager.channel_utilities import clean_urljoin
   from channel_manager.channel_utilities import load_data_file
   from channel_manager.channel_utilities import get_main_directory
   from channel_manager.channel_utilities import get_dictionary_key

   from channel_manager import channel_installer
   from channel_manager import channel_uninstaller

   try:
       from package_control.package_manager import clear_cache

   except ImportError:
       pass

   from channel_manager.channel_manager import main as manager_main
   from channel_manager.submodules_manager import main as submodules_main
   from channel_manager.copy_default_package import main as copy_default_main


   # Infer the correct package name and current directory absolute path
   CURRENT_DIRECTORY    = os.path.dirname( os.path.realpath( __file__ ) )
   CURRENT_PACKAGE_NAME = os.path.basename( CURRENT_DIRECTORY ).rsplit('.', 1)[0]

   # Hold all the information for this channel, which will be used by the `ChannelManager` to install
   # this channel
   g_channel_settings = {}


   def plugin_loaded():
       """
           We can only load the information when the Sublime Text API is available due the use of the
           get_main_directory() which requires it.
       """
       global g_channel_settings

       # The folder where the directory where the Sublime Text `Packages` (loose packages) folder is on
       CHANNEL_ROOT_DIRECTORY = get_main_directory( CURRENT_DIRECTORY )

       # The folder where the User settings are on
       USER_FOLDER_PATH = os.path.join( CHANNEL_ROOT_DIRECTORY, "Packages", "User" )

       # The temporary folder to download the main repository when installing the development version
       g_channel_settings['TEMPORARY_FOLDER_TO_USE'] = "__channel_temporary_directory"
       g_channel_settings['CHANNEL_PACKAGE_NAME']    = CURRENT_PACKAGE_NAME

       # Where to save the settings for channel after it is installed on the user's machine
       g_channel_settings['USER_FOLDER_PATH']              = USER_FOLDER_PATH
       g_channel_settings['CHANNEL_INSTALLATION_SETTINGS'] = \
               os.path.join( USER_FOLDER_PATH,CURRENT_PACKAGE_NAME + ".sublime-settings" )


       # The local path to the files, used to save the generated channels. Valid URLs to the files, to use
       # when installing the stable version of the channel See also:
       # https://packagecontrol.io/docs/channels_and_repositories

       # The default Package Control channel
       g_channel_settings['DEFAULT_CHANNEL_URL'] = "https://packagecontrol.io/channel_v3.json"

       # The URL of the directory where the files `channel.json` and `repository.json` are hosted
       CHANNEL_RAW_URL = "https://raw.githubusercontent.com/your_user_name/MyBrandNewChannel/master/"

       # The URL to the main A direct URL/Path to the repository where there is the `.gitmodules` file
       # listing all the channel packages to use when generating the Channel files.
       g_channel_settings['CHANNEL_ROOT_URL']       = "https://github.com/your_user_name/MyParentRepository"
       g_channel_settings['CHANNEL_ROOT_DIRECTORY'] = CHANNEL_ROOT_DIRECTORY

       # The file path to the Channel File `channel.json` to use when installing the development version
       g_channel_settings['CHANNEL_FILE_URL']  = clean_urljoin( CHANNEL_RAW_URL, "channel.json" )
       g_channel_settings['CHANNEL_FILE_PATH'] = os.path.join( CURRENT_DIRECTORY, "channel.json" )

       # A direct URL/Path to the Repository File `repository.json` to use when installing the
       # stable/development version
       g_channel_settings['CHANNEL_REPOSITORY_URL']  = clean_urljoin( CHANNEL_RAW_URL, "repository.json" )
       g_channel_settings['CHANNEL_REPOSITORY_FILE'] = os.path.join( CURRENT_DIRECTORY, "repository.json" )

       # A direct URL/Path to the `settings.json` to use when installing the stable/development version
       g_channel_settings['CHANNEL_SETTINGS_URL']  = clean_urljoin( CHANNEL_RAW_URL, "settings.json" )
       g_channel_settings['CHANNEL_SETTINGS_PATH'] = os.path.join( CURRENT_DIRECTORY, "settings.json" )

       # The default user preferences file
       g_channel_settings['USER_SETTINGS_FILE'] = "Preferences.sublime-settings"


       # You can specify for some packages to be popped out from the list and being installed by
       # first/last in the following order presented.
       g_channel_settings['PACKAGES_TO_INSTALL_FIRST'] = \
       [
           "My First Package",
           "My Second Package",
           "My Third Package",
       ]

       g_channel_settings['PACKAGES_TO_INSTALL_LAST'] = \
       [
           "My Package Penultimate Package",
           "My Package Penult Package",
           "My Package Last Package",
       ]

       # Packages which are not allowed to be selected by the user while choosing the packages to not
       # be installed. Useful for packages which are required for the channel maintainability.
       g_channel_settings['FORBIDDEN_PACKAGES'] = \
       [
           "My First Forbidden Package",
           "My Second Forbidden Package",
       ]

       # Packages which you do want to install when reading the `.gitmodules` packages list (stable)
       g_channel_settings['PACKAGES_TO_NOT_INSTALL_STABLE'] = \
       [
           "My First Package to not Install",
           "My Second Package to not Install",
       ]

       # Packages which you do want to install when reading the `.gitmodules` packages list (development)
       g_channel_settings['PACKAGES_TO_NOT_INSTALL_DEVELOPMENT'] = \
       [
           "My First Package to not Install",
           "My Second Package to not Install",
       ]

       # The files of the `Default.sublime-package` you are installing
       g_channel_settings['DEFAULT_PACKAGES_FILES'] = \
       [
           "Tab Context.sublime-menu",
           "Context.sublime-menu",
       ]


   def is_channel_installed():
       """
           Returns True if the channel is installed, i.e., there are packages added to the
           `packages_to_uninstall` list.
       """

       # Only attempt to check it, if the settings are loaded
       if len( g_channel_settings ) > 0:
           channelSettingsPath = g_channel_settings['CHANNEL_INSTALLATION_SETTINGS']

           if os.path.exists( channelSettingsPath ):
               settings = load_data_file( channelSettingsPath )
               return len( get_dictionary_key( settings, "packages_to_uninstall", [] ) ) > 0

       return False


   def add_channel():
       """
           Add your channel URL to the Package Control channel list and cleans the cached channels.
       """
       package_control = "Package Control.sublime-settings"
       channel_url     = g_channel_settings['CHANNEL_FILE_URL']

       package_control_settings = sublime.load_settings( package_control )
       channels                 = package_control_settings.get( "channels", [] )

       while channel_url in channels:
           channels.remove( channel_url )

       channels.append( channel_url )
       package_control_settings.set( "channels", channels )

       print( "Adding %s channel to %s: %s" % ( CURRENT_PACKAGE_NAME, package_control, str( channels ) ) )
       sublime.save_settings( package_control )

       clear_cache()


   class MyBrandNewChannelRunUninstallation( sublime_plugin.ApplicationCommand ):

       def run(self):
           sublime.active_window().run_command( "show_panel", {"panel": "console", "toggle": False} )
           channel_uninstaller.main( g_channel_settings )


   class MyBrandNewChannelRunInstallation( sublime_plugin.ApplicationCommand ):

       def run(self, version="stable"):
           """
               Call the ChannelManager installer to install all the channel packages.

               @param version   Either the value "stable" or "development" to install the
                                Development or Stable Version of the channel.
           """
           add_channel()
           g_channel_settings['INSTALLATION_TYPE'] = version

           sublime.active_window().run_command( "show_panel", {"panel": "console", "toggle": False} )
           channel_installer.main( g_channel_settings )

       def is_enabled(self):
           return not is_channel_installed()


   class MyBrandNewChannelGenerateChannelFile( sublime_plugin.ApplicationCommand ):

       def run(self, command="all"):
           sublime.active_window().run_command( "show_panel", {"panel": "console", "toggle": False} )
           manager_main( g_channel_settings, command )

       def is_enabled(self):
           return is_channel_installed()


   class MyBrandNewChannelRun( sublime_plugin.ApplicationCommand ):

       def run(self, run):
           sublime.active_window().run_command( "show_panel", {"panel": "console", "toggle": False} )
           submodules_main( run )

       def is_enabled(self):
           return is_channel_installed()


   class MyBrandNewChannelExtractDefaultPackages( sublime_plugin.ApplicationCommand ):

       def run(self):
           sublime.active_window().run_command( "show_panel", {"panel": "console", "toggle": False} )
           copy_default_main( g_channel_settings['DEFAULT_PACKAGES_FILES'], True )

       def is_enabled(self):
           return is_channel_installed()
   ```

1. Lastly we need to make these commands from our configuration file named
   `settings_and_commands.py` (or the name you picked up) available for the user to install your
   channel. Remembering, to create the channel, i.e, generate the files `channel.json` and
   `repositories.json`, you need to have everything installed as Development Version with all
   packages cloned as git submodules with the `--recursive` option (if applied).

   Creating a file like these should be able to make you new commands for you channel
   `MyBrandNewChannel` to be accessible easily. You can create a file named
   `Commands.sublime-commands` inside your `MyBrandNewChannel` directory:
   ```javascript
   [
       { "caption": "My Brand New Channel: Generate Channel File",
               "command": "my_brand_new_channel_generate_channel_file",
               "args": {"command": "all" } },

       { "caption": "My Brand New Channel: Select Package to Update Git Tag",
               "command": "my_brand_new_channel_generate_channel_file",
               "args": {"command": "git_tag" } },

       { "caption": "My Brand New Channel: Update All Packages Git Tag",
               "command": "my_brand_new_channel_generate_channel_file",
               "args": {"command": "git_tag_all" } },

       { "caption": "My Brand New Channel: Run Stable Installation",
               "command": "my_brand_new_channel_run_installation",
               "args": {"version": "stable"} },

       { "caption": "My Brand New Channel: Run Development Installation",
               "command": "my_brand_new_channel_run_installation",
               "args": {"version": "development"} },

       { "caption": "My Brand New Channel: Run Uninstallation",
               "command": "my_brand_new_channel_run_uninstallation" },

       { "caption": "My Brand New Channel: Extract Default Package",
               "command": "my_brand_new_channel_extract_default_packages" },

       { "caption": "My Brand New Channel: Run Backstroke Requests",
               "command": "my_brand_new_channel_run", "args": {"run": "-b"} },

       { "caption": "My Brand New Channel: Fetch All Submodules remote origin",
               "command": "my_brand_new_channel_run", "args": {"run": "-fo"} },

       { "caption": "My Brand New Channel: Pull & Rebase All Submodules (git)",
               "command": "my_brand_new_channel_run", "args": {"run": "-p"} },

       { "caption": "My Brand New Channel: Pull & Rebase All Submodules (python)",
               "command": "my_brand_new_channel_run", "args": {"run": "-o"} },

       { "caption": "My Brand New Channel: Push Local Git Tags",
               "command": "my_brand_new_channel_run", "args": {"run": "-t"} },

       { "caption": "My Brand New Channel: Add All Upstreams Remotes",
               "command": "my_brand_new_channel_run", "args": {"run": "-u"} },

       { "caption": "My Brand New Channel: Delete All remote Except origin",
               "command": "my_brand_new_channel_run", "args": {"run": "-d"} },
   ]
   ```

1. Although if you prefer, you can provide a menu entry for these commands instead of providing them
   by the command palette. You just need to create the file called `Main.sublime-menu` inside your
   `MyBrandNewChannel` directory:
   ```javascript
   [
       {
           "caption": "Preferences",
           "mnemonic": "n",
           "id": "preferences",
           "children":
           [
               {
                   "caption": "Package Settings",
                   "mnemonic": "P",
                   "id": "package-settings",
                   "children":
                   [
                       {
                           "caption": "My Brand New Channel",
                           "children":
                           [
                               { "caption": "Generate Channel File",
                                       "command": "my_brand_new_channel_generate_channel_file",
                                       "args": {"command": "all" } },

                               { "caption": "Select Package to Update Git Tag",
                                       "command": "my_brand_new_channel_generate_channel_file",
                                       "args": {"command": "git_tag" } },

                               { "caption": "Update All Packages Git Tag",
                                       "command": "my_brand_new_channel_generate_channel_file",
                                       "args": {"command": "git_tag_all" } },

                               { "caption": "Run Stable Installation",
                                       "command": "my_brand_new_channel_run_installation",
                                       "args": {"version": "stable"} },

                               { "caption": "Run Development Installation",
                                       "command": "my_brand_new_channel_run_installation",
                                       "args": {"version": "development"} },

                               { "caption": "Run Uninstallation",
                                       "command": "my_brand_new_channel_run_uninstallation" },

                               { "caption": "Extract Default Package",
                                       "command": "my_brand_new_channel_extract_default_packages" },

                               { "caption": "Run Backstroke Requests",
                                       "command": "my_brand_new_channel_run", "args": {"run": "-b"} },

                               { "caption": "Fetch All Submodules remote origin",
                                       "command": "my_brand_new_channel_run", "args": {"run": "-fo"} },

                               { "caption": "Pull & Rebase All Submodules (git)",
                                       "command": "my_brand_new_channel_run", "args": {"run": "-p"} },

                               { "caption": "Pull & Rebase All Submodules (python)",
                                       "command": "my_brand_new_channel_run", "args": {"run": "-o"} },

                               { "caption": "Push Local Git Tags",
                                       "command": "my_brand_new_channel_run", "args": {"run": "-t"} },

                               { "caption": "Add All Upstreams Remotes",
                                       "command": "my_brand_new_channel_run", "args": {"run": "-u"} },

                               { "caption": "Delete All remote Except origin",
                                       "command": "my_brand_new_channel_run", "args": {"run": "-d"} },
                           ]
                       }
                   ]
               }
           ]
       }
   ]
   ```

If you want to get more elaborated with the installation process, you can see the
[StudioChannel](https://github.com/evandrocoan/SublimeStudioChannel) and the
[AmxxChannel](https://github.com/evandrocoan/SublimeAmxxChannel) files as example. The `AmxxChannel`
implementation is similar to the one presented just above. However, the `StudioChannel` is pretty
much different. It employs use concept of Installation Wizard, presenting a survey of the contents
being installed.



___
## How to Use a Channel <sub><sub>[Go to Top](#channel-manager)</sub></sub>

The Channel is usable by two ways, the first is to create a big channel as Package Control with like
2000 packages or much more, listed by the `.gitmodules` file. The second is by creating a small
channel of packages with with just a few packages as about 10 or 100 packages.

The first usage is when you intend just create big list of packages for sharing like Package Control
does. This would not allow anyone to attempt to use the channel installer, as it would install all
the packages, which is a lot of them. However this has the downside of requiring all the packages to
be cloned on your computer for generating the `channel.json` and `repository.json` file.

It is made like to so it is not required to have an GitHub API token access, as you can only perform
60 access per hour without one. Now instead of pulling GitHub server with requests for the packages
data, we just access it by the command line interface as the package is cloned locally in your
computer.

The second usage is when you intend to share with our work colleagues or friends, a bundled set of
packages for Sublime Text. You can just pass the channel URL for them to add it to the Package
Control channel's list, then they can install your channel and run its installer.

When the user finish the installation of the channel, the `ChannelManager` dependency will show up a
message dialog informing whether the installation was successful or not:

![Successful Installation Message Dialog](https://i.imgur.com/GcGa2MY.png)


### Multiple Channels Installation <sub><sub>[Go to Top](#channel-manager)</sub></sub>

You can install as many Stable Versions of the channels as you want to. However, the Development
Version due its nature can only have one installed. If you attempt to install a second Development
Version, the `ChannelManager` will not let you. But it stills installing the packages which are not
present on the current installed channel.

Despite you cannot install multiple Development Versions, you can still install one Development
Version and as much Stable Versions you would like to. Nevertheless, the packages which each channel
have in common, are going to overridden accordingly to the channels installation order. For example,
if you installed a Channel A, then another Channel B, and both channels have in common the same
Package C, the implementation of the Package C, by the Channel A, will be overridden by the
implementation of the Channel B, i.e., they are overridden accordingly to the order of the most
recent channel installation.

It is also implemented on the `ChannelManager` dependency, an short installation wizard which should
allow you to choose which packages of Channel you do not want to install. Therefore you could select
which of these packages you would like to install over the packages you already has installed.
However, this list limited by the setting `FORBIDDEN_PACKAGES` which specify packages which must be
installed. If the user do not agree with installing these packages, then he cannot install the
channel.



___
## Commands <sub><sub>[Go to Top](#channel-manager)</sub></sub>

It provides the following commands on command palette. Note these commands only works if you
installed the Development Version of the channel:

1. **YourChannelName: Generate Channel File** Creates the files `channel.json`, `repositories.json`
   and `settings.json`. The file `channel.json` and `repositories.json` are the same file as the
   Package Control's [channel_v3.json](https://packagecontrol.io/channel_v3.json) file.

   The file `settings.json` is used to save additional settings for the channel. Currently it only
   list the default ignored packages which are set when you use the Development Version, instead of
   the Stable Version of the channel. You can read more about them at [Package Control, Docs:
   Channels and Repositories](https://packagecontrol.io/docs/channels_and_repositories)

1. **YourChannelName: Select Package to Update Git Tag** Before running this command, you must have
   already called `Generate Channel File` to create the channel files, as this commands just load
   those files and create a git tag as performed on the command `Generate Channel File and Tags`,
   however the tag is only created if it does not already exists a tag for the current/latest
   commit. Also, the tag is immediately pushed to origin.

1. **YourChannelName: Update All Packages Git Tag** Similar to the last command `Select Package
   to Update Git Tag`, but it create tags for each repository on based on the date of the last
   commit. If there is no tags, a first tag is created as `1.0.0`. If already there are tags, its
   patch component (or major.minor.patch) is incremented in one.

1. **YourChannelName: Run Backstroke Requests** Backstroke is a Github bot to keep repository forks up
   to date with their upstream. Therefore, if you setup your own list of Backstroke URLs, you can
   run this command to ping all your URLs, so their upstreams are checked whether there are some
   missing updates.

1. **YourChannelName: Push Local Git Tags** Walk through all git repositories and perform the `git
   push --tags` command, i.e., perform a git push for all submodules tags to their respective remote
   repository.

1. **YourChannelName: Fetch All Submodules remote origin** Walk through all git repositories and
   perform the `git fetch origin` command, i.e., fetch the updates from the origin, using python
   script which walk recursively into submodules of submodules. This command also which display the
   remaining time.

1. **YourChannelName: Pull & Rebase all Submodules (git)** Walk through all git repositories and
   perform the `git pull --rebase` command, i.e., fetch the updates from the origin and merge the
   changes by rebase, using git submodules which walk recursively into submodules of submodules and
   performing checkout on their master branch.

1. **YourChannelName: Pull & Rebase all Submodules (python)** Walk through all git repositories and
   perform the `git pull --rebase` command, i.e., fetch the updates from the origin and merge the
   changes by rebase, using python script which walk recursively into submodules of submodules but
   does not checkout on their master branch.

   Notice it is required to they to be checkout on some branch before doing git pull. Then it is
   useful to run first the command `Pull & Rebase all Packages (git)` when you first install the git
   submodules and on the remaining times, call this command which display the remaining time.

1. **YourChannelName: Pull & Rebase all Upstreams** (Not Yet Implemented) Walk through all git
   repositories and perform `git remote add upstream_url`, checkout on the specified remote branch,
   and do a git merge with the upstream contents.

   This is not yet implemented, it should require a new settings entry key on the `.gitmodules` to
   set which one should be the remote branch used to checkout to do the merge. Otherwise, if the
   setting is not set/present, the default branch would be used.

1. **YourChannelName: Add All Upstreams Remotes** Walk through all git repositories and add as
   remote their upstream set on the file `.gitmodules`, if it exists. The upstream will have the
   username of the upstream user.

1. **YourChannelName: Delete All remote Except origin** Walk through all git repositories and delete
   all remotes which are not `origin` and the `upstream username`. This is useful to clean all the
   remotes repositories after running the `find_forks` command.

1. **YourChannelName: Extract Default Package** Run the script `copy_default_package.py` which
   unpack_settings the `Default.sublime-package` at the on the `Packages/../` folder, i.e., on the
   folder which the Sublime Text loose packages are, not inside it. This command automatically runs
   when you install a new version of Sublime Text, therefore the command is only here when you want
   to force it to override the current files.

1. **YourChannelName: Run Stable Installation** Run the script `channel_installer.py` which install
   all the channel Stable Version packages which are configured to be installed accordingly to the
   file `settings.py` at `YourChannelName` channel repository.

   The installer can only be run once. If the installation was interrupted by closing Sublime Text,
   you first need to call the command `Run Uninstallation` to uninstall all the installed packages
   and only then to call this installer the `Run Stable Installation` command again.

1. **YourChannelName: Run Development Installation** Run the script `channel_installer.py` which
   install all the channel Development Version packages which are configured to be installed
   accordingly to the file `settings.py` at `YourChannelName` channel repository.

   The installer can only be run once. If the installation was interrupted by closing Sublime Text,
   you first need to call the command `Run Uninstallation` to uninstall all the installed packages
   and only then to call this installer the `Run Stable Installation` command again.

1. **YourChannelName: Run Uninstallation** Run the script `channel_uninstaller.py` which uninstall
   all the channel Stable or Development Version packages which were installed accordingly to the
   file `settings.py` at `YourChannelName` channel repository.

   The uninstaller run multiple, if the uninstallation was interrupted by closing Sublime Text, you
   can call the command `Run Uninstallation` continue to uninstall all the installed packages once
   you start Sublime Text again.



___
## Installation Notes <sub><sub>[Go to Top](#channel-manager)</sub></sub>

1. This may show up close to the installation end:

   ![error: PackagesManager](https://i.imgur.com/bmZ5Jso.png)
   ```
   error: PackagesManager

   The package specified, Package Control, is not installed

                   If there will be new messages on the next seconds,
                   they will be show on the Sublime Text console
   ```

   You can just ignore this. It happens because both PackagesManager and the installer try to
   uninstall `Package Control`. Someday this should be fixed, then only one of them attempt to do
   it. It is not always required to replace the `Package Control` by the `PackagesManager`, it
   depends on the channel configuration. However most of the commands will not work with `Package
   Control`. This is because was added some functionality to `PackagesManager`, which is not present
   on `Package Control`.

1. Currently it has the problem of showing up this error box randomly. This may or may not happen
   when you run the installer:

    ![Error Box](https://i.imgur.com/WppRKNt.png)

    This happens at this moments:
    ```
    ignored packages updated to: ["Vintage", "Uncrustify", ..., AdvancedNewFile", "AlignTab"]
    reloading settings Packages/User/Preferences.sublime-settings
    ignored packages updated to: ["Vintage"]
    ignored packages updated to: ["Vintage", "Uncrustify", ..., AdvancedNewFile", "AlignTab"]
    reloading settings Packages/User/Preferences.sublime-settings
    ignored packages updated to: ["Vintage"]
    ignored packages updated to: ["Vintage", "Uncrustify", ..., AdvancedNewFile", "AlignTab"]
    reloading settings Packages/User/Preferences.sublime-settings
    ignored packages updated to: ["Vintage"]
    ignored packages updated to: ["Vintage", "Uncrustify", ..., AdvancedNewFile", "AlignTab"]
    reloading settings Packages/User/Preferences.sublime-settings
    ignored packages updated to: ["Vintage"]
    ignored packages updated to: ["Vintage", "Uncrustify", ..., AdvancedNewFile", "AlignTab"]
    reloading settings Packages/User/Preferences.sublime-settings
    ignored packages updated to: ["Vintage"]
    ignored packages updated to: ["Vintage", "Uncrustify", ..., AdvancedNewFile", "AlignTab"]
    reloading settings Packages/User/Preferences.sublime-settings
    reloading settings Packages/User/Preferences.sublime-settings

        It appears a package is trying to ignore itself, causing a loop.
        Please resolve by removing the offending ignored_packages setting.
    ```

    It is unknown yet what is setting the `ignored_packages` setting to `["Vintage"]`. That is why
    was wrote this function:
    ```python
    def add_packages_to_ignored_list(packages_list):
        """
            Something, somewhere is setting the ignored_packages list to `["Vintage"]`. Then ensure we
            override this.
        """
        ignored_packages = g_user_settings.get( "ignored_packages", [] )
        unique_list_append( ignored_packages, packages_list )

        for interval in range( 0, 27 ):
            g_user_settings.set( "ignored_packages", ignored_packages )
            sublime.save_settings( USER_SETTINGS_FILE )

            time.sleep(0.1)
    ```
    Perhaps `Package Control` is doing it, as this error showed up in a vanilla install only with
    `Package Control` installed. The problem seems random and does not to happens every time you run
    the channel installer.

1. This error also may or may not show up when you run the installer:

    ![Error while loading PyV8 binary](https://i.imgur.com/elyZJ9A.png)

    ```
    emmet.pyv8loader: Unable to download packages list. HTTP error 403 downloading
    https://api.github.com/repos/emmetio/pyv8-binaries/contents.
    error: Error while loading PyV8 binary: exit code 1
    Try to manually install PyV8 from
    https://github.com/emmetio/pyv8-binaries
    ```

    It seems it cannot always download the `pyv8-binaries` as the GitHub may be throttling your
    connection as you just downloaded a lot of contents. So, you can try to manually download the
    contents at [pyv8-binaries](https://github.com/emmetio/pyv8-binaries) or just wait another hour
    and restart Sublime Text, so the package can download the contents by itself.

1. Sublime Text may enter on deadlock, while Package Control is installing the missing dependencies.
   This has a similar issue registered at
   [CoreIssues$1966](https://github.com/SublimeTextIssues/Core/issues/1966)(Deadlock/hang when batch
   deleting/creating settings files). The solution to this is to notice when Sublime Text is hanged
   with no CPU usage, i.e., for some time it is unresponsive, then you need to kill Sublime Text
   itself or just kill the program called `plugin_host` or `plugin_host.exe`. After killing
   `plugin_host`, Sublime Text will became responsive again, then you can save your work and restart
   Sublime Text to restore the Sublime Text packages functionality.



## Development Problems
___

1. The Development Version currently cannot install the dependencies `PythonDebugTools` and
   `ChannelManager` as Package Control always unpack package dependencies. Because to install the
   development packages, it required to they do not exists on the user loose `Packages` folder. But
   as Package Control unpacks them when installing the required dependencies, the installer cannot
   clone and install the files.

   The solution to this problem is to Package Control accept some dependencies to be installed
   inside a `sublime-package`. There is a open pull request for Package Control allowing this
   feature: [Pull$1291](https://github.com/wbond/package_control/pull/1291) Allowed PythonDebugTools
   to be import from a .sublime-package file.

   The work around to fix this, is after the Development Version installation process to be
   finished, delete the created folders by Package Control and clone these two repositories
   manually.

1. If the latest existent tag is on the form `3144`, the command which automatically update the tag
   will not fail to increment/create new tags after it, as they fetch the latest tags available from
   the repository. Currently it is not implemented the code to automatically figure out such tags
   and then try the get some older tag on the correct format.



___
## License <sub><sub>[Go to Top](#channel-manager)</sub></sub>

All files in this repository, i.e., excluding its `git submodules` and the files which include its
own license header, are released under GNU General Public License v3.0 or the latest version
available on http://www.gnu.org/licenses/gpl.html

For more information see:

1. The [LICENSE](LICENSE) file for the GPL v3.0 license
1. The website https://www.gnu.org/licenses/gpl-3.0.en.html


